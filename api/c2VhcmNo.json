[{"title":"CCU_ACM大二新手测试题解","date":"2019-10-27T07:29:26.265Z","updated":"2019-10-27T07:33:34.076Z","content":"A.ACM不需要视力！！！\nB.略。。。\nC.Equalize Prices Again\n题意：给定t组数据，每组数据有n个元素，求一个整数，使其大于等于这组数据的平均值。\n思路：求平均值即可。\n1234567891011121314151617181920212223#include&lt;iostream&gt; using namespace std; int q , n , x;long long sum ;int main()&#123;    cin &gt;&gt; q;    while( q-- )&#123;        sum = 0;        cin &gt;&gt; n ;        for(int i = 1 ; i &lt;= n ; i++)        &#123;            cin &gt;&gt; x;            sum += x;        &#125;        if( sum/n*n &lt; sum ) cout  &lt;&lt; sum/n+1 &lt;&lt; endl;        else            cout &lt;&lt; sum/n &lt;&lt; endl;    &#125;    return 0;&#125;\n\nD.Wrong Subtraction\n题意：给定一个数，让你进行k次操作，操作如下：\n​        1.如果这个数的末尾不是0，则将该数减一\n​        2.如果这个数的末尾是0，则将该数除以10\n思路：模拟即可\n12345678910111213141516171819#include &lt;iostream&gt; using namespace std;  int a, k ; int main()&#123;     cin &gt;&gt; a &gt;&gt; k ;    while( k-- )&#123;        if( a % 10 != 0 )   a--;        else    a /= 10;    &#125;    cout &lt;&lt; a  &lt;&lt; endl;        return 0;&#125;\n\nE.Social Network (easy version)\n题意：（模拟了一个消息列表。）你有预知未来的能力，能够知道未来一天内会有n条消息（信息可能由一个人发出，也可能由不同的人发出）发到你的手机上。你的手机屏幕在同一时间只能显示k条消息。\n现在规定：1，如果手机屏幕上已经有此人的消息，则再接收到该人的消息时，屏幕不发生变化。\n​                    2，如果此人的消息不再屏幕上，则将此消息置顶，其他消息向下移动一格，如果此时屏幕已经放不下                          这么多条信息，则将最底下的消息移出屏幕。\n输入：n，k和接下来一天的信息（已经按时间顺序排好），每条信息由编号为\ni\n\n\n\n\n \n\n的人发出。\n输出：手机屏幕上最后显示的消息是由哪几个发出的，输出顺序为从屏幕顶部到底部。\n思路：只需队列模拟即可，在进队之前判断此元素是否在队列中。\n注意：由于\ni\n\n\n\n\n \n\n的编号范围为\n1-10^9\n\n\n\n\n\n\n\n \n \n\n \n \n \n\n\n，因此用开数组的方式来标记是行不通的，因此要么先离散化，要么就是用set或者map来标记是否在队列中。\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;deque&gt;using namespace std; typedef long long LL ; const int N = 2e5+10; int n , k ;int a[N]  ;set&lt;int &gt; g;deque&lt;int&gt; dq; int main()&#123;    while(cin &gt;&gt; n &gt;&gt; k ) &#123;        g.clear();        dq.clear();        while (n--) &#123;            int x;            cin &gt;&gt; x;            if (g.find(x) == g.end()) &#123;//不在队列中                dq.push_front(x);                g.insert(x);            &#125;                        if (dq.size() &gt; k) &#123;                int t = dq.back();                dq.pop_back();                g.erase(t);            &#125;         &#125;        cout &lt;&lt; dq.size() &lt;&lt; endl;        for (auto x : dq) cout &lt;&lt; x &lt;&lt; \" \";        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n\nF.Two-gram，\n题意：给定一个字符串，输出出现次数最多的长度为二的字串。\n思路：利用STL中的map，建立string –&gt; int 的键值关系进行计数即可。\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt; using namespace std;  map&lt;string,int&gt; g; int n ;string s; int main()&#123;    cin &gt;&gt; n &gt;&gt; s ;    string str;    string ans ;    int t = 0 ;    for(int i = 0 ; i &lt; n-1 ; i++)&#123;        str = s.substr(i,2) ;        //cout &lt;&lt; str &lt;&lt; endl;        g[str]++;     &#125;     for(auto x : g)        if(x.second &gt; t)&#123;            t = x.second;            ans = x.first;        &#125;    cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;\n\nG.Array Stabilization\n题意：将\na\n\n\n\n\n \n\n数组中删除一个数，使得\nmax(a_i) - min(a_i)\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n \n \n \n \n \n \n\n \n \n\n \n\n最小，数据保证数组元素大于等于2。\n思路：只需排个序，判断\na[n-1]-a[1] 和 a[n]-a[2]\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n和\n\n \n \n \n \n \n \n \n \n \n\n谁小即可\n123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; const int N = 1e5+10; int n , a[N] ; int main()&#123;    cin &gt;&gt; n ;    for(int i = 1 ; i &lt;= n ; i++ )   cin &gt;&gt; a[i] ;    sort( a+1 , a+n+1 );     cout &lt;&lt; min(a[n-1]-a[1] , a[n]-a[2]) &lt;&lt; endl;    return 0 ;&#125;\n\nH.Polycarp Training\n题意：小明要开始做刷题训练，决心第\nk\n\n\n\n\n \n\n天做\nk\n\n\n\n\n \n\n道题目，但是如果第\nk\n\n\n\n\n \n\n天做不到\nk\n\n\n\n\n \n\n题，则训练结束。问他最多能训练多少天。接下来给定一些卷子，每张卷子上有\na[i]\n\n\n\n\n\n\n\n \n \n \n \n\n道题目，每天他只能选一张卷子做。假设第\nk\n\n\n\n\n \n\n天，如果试卷上面的题目大于等于\nk\n\n\n\n\n \n\n，则说明这张卷子可以拿来做，并且做完之后，这张卷子就要被丢弃。\n思路：只需将试卷的题数从小到大排个序，在利用一个指针遍历一遍即可。\n1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; const int N = 2e5+10; int n , a[N] ;int main()&#123;    cin &gt;&gt; n;    for(int i = 0 ; i &lt; n ; i++ )   cin &gt;&gt; a[i];    sort(a , a+n);    int l = 1;    for(int i = 0 ; i &lt; n ; i++ )&#123;        if( a[i] &gt;= l ) l++;    &#125;    cout &lt;&lt; l-1 &lt;&lt; endl;    return 0;&#125;\n\nI.Remainder\n题意：给定一个n位的只含0和1的十进制数t，再给定x和y，每一次变换可以将0变成1或者将1变成0，问最少变换几次，使得\nt \n\n\n\n\n \n\n mod \n10^x = 10^y\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n\n\n。\n思路：只需将最后\nx-1\n\n\n\n\n\n\n \n \n \n\n位中除了倒数第\ny\n\n\n\n\n \n\n位的\n1\n\n\n\n\n \n\n变为\n0\n\n\n\n\n \n\n，然后再判断倒数第\ny\n\n\n\n\n \n\n位是\n0\n\n\n\n\n \n\n还是\n1\n\n\n\n\n \n\n即可。\n123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; string s;int n , x , y; int main()&#123;            cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;        cin &gt;&gt; s;        int ans = 0;         for (int i = 0; i &lt; x; i++) &#123;            if (i == y) continue;            if (s[n - 1 - i] == '1')                ans++;         &#125;        if (s[n - 1 - y] == '0') ans++;         cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;\n\nJ.Good String\n题意：如果一个字符串是偶数，且字符串的奇数位和他的下一个偶数位不相同，则我们把这个字符串叫做good string，空字符串显然为good string。你的任务是用最小的删除操作（每次只能删除一个字符），将一个字符串变成good string。输出最小删除的字符个数和最后留下的good string。\n思路：栈模拟。\n1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int n ;string s;string ans; int main()&#123;    cin &gt;&gt; n &gt;&gt; s ;    for(int i = 0 ; i &lt; s.length() ; i++ )&#123;        if( ans.length() % 2 == 0 || ans.back() != s[i] )            ans.push_back(s[i]);    &#125;    if(ans.size() % 2 == 1) ans.pop_back();    cout &lt;&lt; s.length() - ans.length() &lt;&lt; endl &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n\nK.Almost All Divisors\n题意：给定一个数组，判定这个数组是否是一个almost_all divisor(包含除1和他本身之外的所有其他元素)\n思路：1.判定能否确定一个数。只需给这个数组排序，然后双指针最大*最小是否都是一个数即可。\n​            2.判定这个数的所有因子是否都在给定的数组中\n​                （1）当数组元素个数为1时，特判素数（由于数据有毒，这里需要用到素数筛快速判定）\n​                （2）当数组元素个数大于1时，直接枚举即可（\nsqrt(n)\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n）\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt; using namespace std; const int N = 2e6+10; long long t , n , a[N] ; bool d[N];  //isPrimeint b[N];void isPrime(int n)&#123;    int c=0;    memset(d , 1 , n);    d[1] = false;    for(int i=2 ; i &lt;= n ; i++)&#123;        if( d[i] )            b[c++] = i;        for(int j = 0 ; j &lt; c &amp;&amp; b[j]*i &lt;= n ; j++)&#123;            d[b[j]*i]=false;            if(i%b[j]==0)                break;        &#125;    &#125;&#125; int main()&#123;     isPrime( 2000005);    cin &gt;&gt; t;     while( t-- )&#123;        cin &gt;&gt; n ;        for(int i = 0 ; i &lt; n ; i++ )   cin &gt;&gt; a[i];        sort(a , a+n);         int i = 0 , j = n-1;        long long ans = a[i]*a[j] ;        bool flag = true;        long long res;         for( ; i &lt;= j ; i++, j-- )&#123; //判定是否同一            if( a[i]*a[j] != ans )&#123;                flag = false;                break;            &#125;        &#125;         if( flag )&#123; //判断是否为almost all            if( n == 1 )&#123;                if( !d[a[0]] )   flag = false;            &#125;else&#123;                int res = 0;                long long k;                for( k = 2 ; k*k &lt; ans ; k++) &#123;                    if (ans % k == 0) res += 2 ;                    if(res &gt; n )    break;                &#125;                if( k*k == ans )    res++;                if( res != n )  flag = false;            &#125;        &#125;         if( flag )  cout &lt;&lt; ans &lt;&lt; endl;        else    cout &lt;&lt; -1 &lt;&lt; endl;     &#125;     return 0;&#125;\n\n","plink":"https://lewiskulen.top/post/CCU-ACM/"},{"title":"practice","date":"2019-08-09T19:28:36.077Z","updated":"2019-08-09T19:28:36.078Z","content":"之前由于配置的问题，导致渲染出错，目前已经解决的问题：&emsp;&emsp;LeTaX数学公式渲染&emsp;&emsp;图片插入&emsp;&emsp;表格渲染需要解决的东西：&emsp;&emsp;js文件配置（svg读取错误）&emsp;&emsp;评论系统&emsp;&emsp;锚点问题，无法实现页内跳转（总是回到上一页）&emsp;&emsp;锚点&emsp;&emsp;加入侧栏调控背景选项栏\n&emsp;&emsp;行列式。\n==插图==（高亮出错）\n\n &emsp;&emsp;行列式在数学中，是一个函数，其定义域为det的矩阵A（即A必须为方阵nxn），取值为一个标量（常用D表示），写作det(A)或 | A | 。\n&emsp;&emsp;接下来介绍行列式的计算方法。对于n阶行列式:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;\n\nA =    \n\t\\begin{vmatrix}        \t\n\t\ta_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n}  \\\\  \n\t\ta_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n}  \\\\\n\t\t\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots  \\\\\n\t\ta_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}  \\\\  \n\t\\end{vmatrix}\t\t= \t \\sum_{j_1j_2\\cdots j_n}  (-1)^{N} a_{1j_{1}} a_{2j_{2}} \\cdots *a_{nj_{n}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n \n \n \n \n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n \n\n \n\n \n \n\n \n \n\n \n\n \n \n\n\n\n \n \n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n \n\n \n\n \n \n\n\n\n \n \n\n \n\n \n\n \n \n\n\n\n\n\n&emsp;&emsp;介绍一个概念：&emsp;&emsp;&emsp;&emsp;逆序：我们称 \n12345678 \\cdots n \\cdots \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n为顺序排列。当我们把1和3调换位置，那么就出现了逆序&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对(3,1),(2,1),(3,2),即前一个数比后面的数大，每两个数称为一对逆序对。\n&emsp;&emsp;其中，排列的逆序对数量 \n\\left \\{\\begin{aligned}奇数(奇排列)\\\\偶数(偶排列)\\end{aligned}\\right. \n\n\n\n\n\n\n\n \n\n\n\n奇\n\n数\n\n \n\n奇\n\n\n排\n\n\n列\n\n \n\n\n偶\n\n数\n\n \n\n偶\n\n\n排\n\n\n列\n\n \n\n\n\n\n 。\n&emsp;&emsp;现在来解释上式：其中\nj_1j_2\\cdots j_n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n\n \n \n\n\n是一个1~n的全排列(有\nn！个\n\n\n\n\n \n\n！\n\n\n个\n\n\n)，N是此排列的逆序对的数量。由此可见，每次选取不同行不同列的元素相乘，再累加求和，即为行列式的值。利用此式很容易计算三角行列式和斜三角行列式，这里就不给出证明了。\n&emsp;&emsp;弱🐔表示很无奈，不过还有其他计算方法。\n 先提几个概念：\n&emsp;&emsp;余子式：在矩阵中，将元素 \na_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n所表示的行和列消去之后所剩下的行列式，即为余子式。\n&emsp;&emsp;代数余子式：即在余子式的值前面乘以一个数。记 \nM_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n 为 \na_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n 的余子式，若\nA_{ij} = (-1)^{i+j}M_{ij} \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n\n \n\n \n \n \n\n\n\n \n\n \n \n\n\n\n，则称 \nA_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n 是 \na_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n 的代数余子式。\n&emsp;&emsp;现在，给出行列式的计算方式：\n&emsp;&emsp;\n D =  j\\sum_1^n  a_{ij} *A_{ij}  \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n   其中j为任意1~n之间的数（按消行）,同理 :&emsp;&emsp;\n D =  i\\sum_1^n  a_{ij} *A_{ij}  \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n   其中i为任意1~n之间的数（按列消）\n接下来我给出一些特殊的行列式:&emsp;&emsp;二阶行列式：\n\n\\begin{vmatrix}\n\t\ta_{11} &amp; a_{12}  \\\\\n\t\ta_{21} &amp; a_{22}  \\\\\n\\end{vmatrix}\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n&emsp;&emsp;&thinsp;因此 \nD = a_{11}*A_{12} + a_{12}*A_{12}\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;\n= a_{11}*a_{22} + (-1)^{(1+2)}a_{12}*a_{21} \n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n \n \n \n\n \n\n \n \n \n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;\n= a_{11}*a_{22} - a_{12}*a_{21}\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n &emsp; (交叉相乘做差)    \n&emsp;&emsp;三阶行列式:\n\n\\begin{vmatrix}\n    a_{11} &amp; a_{12} &amp; a_{13} \\\\        \n    a_{21} &amp; a_{22} &amp; a_{23} \\\\\n    a_{31} &amp; a_{32} &amp; a_{33} \\\\\n\\end{vmatrix}\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n&emsp;&emsp;\nD =  a_{11}*A_{11} + a_{12}*A_{12} + a_{13}*A_{13}\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n    ,其中：\n\nA_{11}=    \n\t\\begin{vmatrix}        \t\n\t\ta_{22} &amp; a_{23}  \\\\   \n\t\ta_{32} &amp; a_{33}  \\\\    \n\t\\end{vmatrix}\n,\nA_{12}=\n\t\\begin{vmatrix}        \t\n\t\ta_{21} &amp; a_{23}  \\\\   \n\t\ta_{31} &amp; a_{33}  \\\\    \n\t\\end{vmatrix}\n,\nA_{13}=\n\t\\begin{vmatrix}        \t\n\t\ta_{21} &amp; a_{22}  \\\\   \n\t\ta_{31} &amp; a_{32}  \\\\    \n\t\\end{vmatrix}\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n \n\n \n\n \n \n\n\n \n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n \n\n \n\n \n \n\n\n \n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n\n直接给出结论 \nD =  a_{11}*a_{22}*a_{33} + a_{12}*a_{23}*a_{31} + a_{13}*a_{21}*a_{32}\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;\n-a_{13}*a_{22}*a_{31} - a_{12}*a_{21}*a_{33} - a_{11}*a_{23}*a_{32}\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n仔细观察，你会发现三阶行列式的计算有规律可循：\n&emsp;&emsp;正对角线（左上到右下）元素累乘，符号为正，正对角线向右平移\n&emsp;&emsp;斜对角线（右上到左下）元素累乘，符号为负，斜对角线向左平移\n看完计算之后，再给出几个特殊行列式的计算公式：\n对角行列式：只有正对角线上有非零元素，其余位置元素均为零\n上下三角行列式：以正对角线为分界线（正对角线上有非零元素元素），对角线以上均为零元素称为下三角，反之是上三角。\n对角行列式和上三角行列式：\nD =   i\\prod_1^n  a_{ii}  \n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n\n \n\n \n \n\n\n\n\n斜三角行列式：只有斜对角线上有非零元素，其余位置元素均为零。\nD =    (-1)^{\\frac{n(n-1)}{2}}i \\prod_1^n  a_{ii}  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n \n\n\n\n\n \n \n \n \n \n \n\n \n\n\n\n \n\n \n \n \n\n\n \n\n \n \n\n\n\n\n行列式的性质:\n\n\n\n性质序列\n内容\n\n\n\n性质一\n\nD = D^T\n\n\n\n\n\n\n \n \n\n \n \n\n\n\n\n\n性质二\n行列式中互换两行,行列式变号(正负号)推论:行列式中有两行完全相同,行列式值为零\n\n\n性质三\n设\nA_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n为\na_{ij}\n\n\n\n\n\n\n \n\n \n \n\n\n的代数余子式,则有:\na_{j1}A_{i1}+ a_{j2}A_{i2} + \\cdots + a_{jn}A_{in} = \\left\\{\\begin{aligned}D&amp; (i  = j)\\\\0 &amp; (i != j)\\end{aligned}\\right.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n\n \n \n\n\n\n \n \n \n \n \n\n\n \n \n \n \n \n \n\n\n\n\n\n\n\n\n性质四\n用数k乘以行列式中的某一行的所有元素,等于k乘以行列式推论:行列式中行与列的公因子可以提到外面\n\n\n性质五\n行列式中某一行元素加上另一行对应元素的k倍,行列式的值不变\n\n\n性质六\n若行列式可以拆成是n个数的和,则行列式可以拆成n个行列式\n\n\n克莱姆法则：(求解线性方程组)\n对于线性方程组A（如下），若\n\nA =    \n\t\\begin{vmatrix}        \t\n\t\ta_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n  \\\\  \n\t\ta_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n  \\\\\n\t\t\\cdots   \\cdots  \\cdots  \\cdots  \\\\\n\t\t\\cdots   \\cdots  \\cdots  \\cdots  \\\\\n\t\ta_{n1}x_1 + a_{n2}x_2 + \\cdots + a_{nn}x_n  \\\\  \n\t\\end{vmatrix}\n=\n​\t\\begin{vmatrix}        \t\n​\t\tb_{1}  \\\\  \n​\t\tb_{2}  \\\\\n​\t\t\\vdots \\\\\n​\t\tb_{n}  \\\\  \n​\t\\end{vmatrix}\n的系数行列式为：\n    \n\\begin{vmatrix}        \t\n    a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n}  \\\\  \n    a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n}  \\\\\n    \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots  \\\\\n    a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}  \\\\  \n\\end{vmatrix}\n= D  != 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n \n \n\n \n\n \n\n \n \n\n\n\n \n \n\n \n \n \n\n \n\n \n \n\n\n\n \n \n\n\n\n \n\n \n \n\n\n \n \n\n \n\n \n\n \n \n\n\n\n \n \n\n \n \n \n\n \n\n \n \n\n\n\n \n \n\n\n\n \n \n \n \n\n\n \n \n \n \n\n\n \n\n \n \n\n\n \n \n\n \n\n \n\n \n \n\n\n\n \n \n\n \n \n \n\n \n\n \n \n\n\n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n \n\n\n \n\n \n\n \n\n\n\n\n\n \n \n\n\n\n\n \n \n\n\n\n \n\n\n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n的\n\n\n系\n\n\n数\n\n\n行\n\n\n列\n\n\n式\n\n\n为\n\n\n：\n\n\n\n \n\n \n\n \n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n \n \n \n \n\n\n\n \n\n \n \n\n\n\n \n\n \n \n\n\n \n\n \n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n \n \n \n \n \n\n\n​    \n\n令系数行列式的第k列\n\\begin{vmatrix}        \t\n​\t\ta_{1k}  \\\\  \n​\t\ta_{2k}  \\\\\n​\t\t\\vdots \\\\\n​\t\ta_{nk}  \\\\  \n​\\end{vmatrix}\n\n为v_{k},列\n\\begin{vmatrix}        \t\n​\t\tb_{1}  \\\\  \n​\t\tb_{2}  \\\\\n​\t\t\\vdots \\\\\n​\t\tb_{n}  \\\\  \n​\\end{vmatrix}\n为v,再令v_{k}与v交换(在D的基础上)所得的新的行列式为D_{k},则\nx_{k} = {\\frac{D_{k}}{D}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n令\n\n系\n\n\n数\n\n\n行\n\n\n列\n\n\n式\n\n\n的\n\n\n第\n\n \n\n列\n\n\n\n \n\n \n\n \n\n\n\n\n\n \n\n \n \n\n\n\n\n\n \n\n \n \n\n\n\n\n \n\n\n\n \n\n \n \n\n\n\n\n\n\n \n\n \n\n \n\n\n\n为\n\n\n \n \n\n \n\n列\n\n\n\n \n\n \n\n \n\n\n\n\n\n \n \n\n\n\n\n \n \n\n\n\n \n\n\n\n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n为\n\n \n \n\n再\n\n\n令\n\n\n \n \n\n\n与\n\n \n\n交\n\n\n换\n\n \n\n在\n\n \n\n的\n\n\n基\n\n\n础\n\n\n上\n\n \n\n所\n\n\n得\n\n\n的\n\n\n新\n\n\n的\n\n\n行\n\n\n列\n\n\n式\n\n\n为\n\n\n \n \n\n \n\n则\n\n\n \n \n\n \n\n\n\n\n \n \n\n \n\n\n\n\n若D&nbsp;!=0&nbsp;,则方程组有唯一解。\n其中，当\nv\n\n\n\n\n \n\n中的元素全为0时，我们称此方程组为齐次线性方程组。若齐次线性方程组的系数行列式&nbsp;D&nbsp;!=0&nbsp;,则方程组有唯一零解（所有x均为0）。\n&emsp;&emsp;范德蒙行列式：\n\n我们把形如\nD = \n\\begin{vmatrix}  \n\t1\t&amp;\t1\t&amp;\t1\t&amp;\t1\t\\\\\n    {a_{1}}^1 &amp; {a_{2}}^1 &amp; \\cdots &amp; {a_{n}}^1  \\\\  \n    {a_{1}}^2 &amp; {a_{2}}^2 &amp; \\cdots &amp; {a_{n}}^2  \\\\\n    \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots  \\\\\n    {a_{1}}^{n-1} &amp; {a_{2}}^{n-1} &amp; \\cdots &amp; {a_{n}}^{n-1}  \\\\\n\\end{vmatrix}\n的行列式称为范德蒙行列式\n\n\n\n\n\n\n\n\n\n\n\n\n\n我\n\n们\n\n\n把\n\n\n形\n\n\n如\n\n \n \n\n\n \n\n \n\n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n\n \n \n \n\n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n\n \n \n \n\n\n\n\n \n \n \n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n\n \n \n \n\n\n\n\n\n \n\n \n\n \n\n\n\n的\n\n\n行\n\n\n列\n\n\n式\n\n\n称\n\n\n为\n\n\n范\n\n\n德\n\n\n蒙\n\n\n行\n\n\n列\n\n\n式\n\n\n\n\nD = \\Pi_{1&lt;=j&lt;i&lt;=n} a_{i}-a_{j} \\\\  \n \t=  (a_{2}-a_{1})(a_{3}-a_{1}) \\cdots (a_{n}-a_{1}) \\\\\n \t\t\t   (a_{3}-a_{2}) \\cdots (a_{n}-a_{2}) \\\\\n\t\t\t   \t\t\t\t \\cdots  \\\\\n \t\t\t   \t\t\t\t \t\t(a_{n}-a_{n-1})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n\n \n \n\n \n \n \n\n \n \n\n \n\n\n\n \n \n\n \n\n \n \n\n\n\n \n \n\n \n \n\n \n\n \n \n\n \n \n\n \n \n\n \n\n \n \n\n \n \n \n\n \n \n\n \n\n \n \n\n \n\n\n \n\n \n \n\n \n\n \n \n\n \n \n \n\n \n \n\n \n\n \n \n\n \n\n\n \n\n\n \n\n \n \n\n \n\n \n\n \n \n \n\n\n \n\n\n\n谨以此篇来练习LaTeX数学公式和测试博客各种渲染和功能。\n锚点\n","plink":"https://lewiskulen.top/post/practice/"},{"title":"new born","date":"2019-07-19T13:44:57.000Z","updated":"2019-08-09T15:42:30.580Z","content":"​        好久没有写博客了，整了一天，这个站也终于算是能看了。暑假得把之前欠下的都补上，任重而道远啊。而且还得继续把这个博客完善。\n​        写这一篇文章主要还是让hello world去死吧！以此纪念新的开始。\n​        以下为我的博客中主要涵盖的知识点：\n​                1.在我所拥有的纸质书中没有\n​                2.主要是数据结构，算法以及数学方面的相关知识\n​                3.以后应该会涉及一些技术方面的博客\n​                \n​        \n​        \n","plink":"https://lewiskulen.top/post/new-born/"}]